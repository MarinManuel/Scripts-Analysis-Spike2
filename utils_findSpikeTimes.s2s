'utils_findSpikeTimes.s2s
'Marin Manuel - Sept 2011
'
'This script is intended to help with the finding of the spike times when spikes are generated by
'short pulses of current and their timing is variable or dubious because of capacitive transients

#include "includes/incl_utilFunctions.s2s"

'hide the current script
if view(App(3)).WindowVisible()>0 then 
    view(App(3)).WindowVisible(0);
endif

const PRETRIGTIME := 1e-3;
const POSTTRIGTIME := 5e-3;


var dataHdl%;
var gateChan%, tempChan%;
var startTime, endTime, curPos, lastPos;
var myCursor%;
var ok%;
var transition;
var lastCurOffset := -1;

if ViewKind()<>0 then
    Message("ERROR: this script must be run on a time view");
    halt
endif

dataHdl% := view();


'default values
gateChan% := 801; 'default to Trig1
startTime := XLow();
endTime := XHigh();

DlgCreate("Parameters");
DlgChan(1, "Membrane Potential Channel",0x1+0x10+0x40+0x200);
DlgChan(2, "Pulse Start Event Channel",0x2+0x4+0x8+0x20);
DlgXValue(3,"Start analysis at");
DlgXValue(4,"  End analysis at");
ok% := DlgShow(vmChan%,gateChan%,startTime,endTime);
if ok% then
    tempChan% := MemChan(3);
    if tempChan%<=0 then
        Message("ERROR: cannot create a memory channel, aborting");
        halt
    endif
    ChanShow(tempChan%);
    
    myCursor% := CursorNew();
    if myCursor%=0 then
        Message("ERROR: cannot create a new cursor, please remove some cursors and try again");
        ChanDelete(tempChan%,0);
        halt
    endif
    CursorLabel(4,myCursor%,">Spike Time<");
    
    if ChanKind(gateChan%)=4 then 'if we have a lvl channel, make a temporary Evt channel instead
        gateChan% := lvl2Evt%(gateChan%, lowHighTransition%, startTime, endTime);
    endif
    
    curPos := startTime;
    doGoNext%();
    
    
    'toolbar
    ToolbarClear();
    ToolbarSet(-1,"&Quit",doQuit%);
    ToolbarSet(2,"&Add||Add this spike and skip to next",doAdd%);
    ToolbarSet(3,"&Ignore/Remove||Remove this spike if set and skip to next",doRemove%);
    ToolbarSet(4,"&Next||Skip to next pulse",doGoNext%);
    ToolbarSet(5,"&Prev||Go back to previous pulse",doGoPrev%);
    Toolbar("Use the buttons to mark the spike times",0);
endif

func doQuit%()
    if tempChan%>0 then
        if Count(tempChan%,startTime,endTime)>0 then
            ok% := Query("Save Spike Time Channel?");
            if ok% then
                'MemSave(tempChan%,0,) 'FIXME: we need to know the destination channel
            else
                ChanDelete(tempChan%,0);
            endif
        else
            ChanDelete(tempChan%,0);
        endif
    endif
    if CursorExists(myCursor%) then
        CursorDelete(myCursor%);
    endif
    XRange(startTime,endTime);
    Draw();
    return 0;
end

func doAdd%()
    if CursorExists(myCursor%) then
        MemSetItem(tempChan%,0,Cursor(myCursor%));
        lastCurOffset := Cursor(myCursor%)-curPos;
    endif
    doGoNext%();
    return 1;
end

func doRemove%()
    MemDeleteTime(tempChan%,3,XLow(),XHigh());
    doGoNext%();
    return 1;
end

func doGoNext%()
    lastPos := curPos;
    curPos := NextTime(gateChan%,curPos);
    if curPos<endTime and curPos>0 then
        XRange(curPos-PRETRIGTIME,curPos+POSTTRIGTIME);
        Draw();
        if lastCurOffset<=0 then
            Cursor(myCursor%,curPos-PRETRIGTIME+(PRETRIGTIME+POSTTRIGTIME)/2.0);
        else
            Cursor(myCursor%,curPos+lastCurOffset);
        endif
    else
        curPos := lastPos;
    endif
    return 1;
end

func doGoPrev%()
    lastPos := curPos;
    curPos := LastTime(gateChan%,curPos,transition);
    if curPos>startTime then
        if transition=0 then 'correct position, at low/high transition
            XRange(curPos-PRETRIGTIME,curPos+POSTTRIGTIME);
            Cursor(myCursor%,curPos-PRETRIGTIME+(PRETRIGTIME+POSTTRIGTIME)/2.0);
        else
            doGoPrev%();
        endif
    else
        curPos := lastPos;
    endif
    return 1;
end
